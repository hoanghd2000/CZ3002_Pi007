import 'dart:io';

import 'package:drift/drift.dart';

// These imports are only needed to open the database
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
// Generated by drift_dev when running `build_runner build`
part 'db_trans_v2.g.dart';

//declaring a table called "dbTrans"
//rows of the table will be represented by a class called "dbTrans
@DataClassName('Txn')
class Txn extends Table {
  //a column that stores int values - id
  //autoincrement of id - primary key of this table
  IntColumn get id => integer().autoIncrement()();

  BoolColumn get spending => boolean()();
  //must create a another category table for users to choose
  TextColumn get category => text()();
  //throw error if minLength is <1 or max is >50.
  TextColumn get name => text().withLength(min:1, max: 50)();

  RealColumn get amount => real()();

  TextColumn get note => text()();
  //how to set it as today's date as default
  DateTimeColumn get timestamp => dateTime().withDefault(currentDateAndTime)();
}

@DriftDatabase(tables : [Txn], daos: [TxnDao])
class TxnDb extends _$TxnDb {
  //tell the database where to store the data with this constructor and logs it
  /*TransDb(): super(_openConnection());*/
  TxnDb(): super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite', logStatements: true));
  // you should bump this number whenever you change or add a table definition.
  // Migrations are covered later in the documentation.
  @override
  int get schemaVersion => 1;


  // //loads all transaction entries
  // Future<List<DbTrans>> get allTransEntries => select(dbTrans).get();
  // // watches all dbTrans entries in a given category. The stream will automatically
  // // emit new items whenever the underlying data changes.
  // Stream<List<DbTrans>> watchEntriesInDbTrans(DbTrans c) {
  //   return (select(dbTrans)..where((t) => t.dbTrans.equals(c.id))).watch();
  // }
  // //The where method takes a function that should map the given table to an Expression of boolean.

}

// Denote which tables this DAO can access
@UseDao(tables: [Txn]) //may need to change to @DriftAccessor
class TxnDao extends DatabaseAccessor<TxnDb> with _$TxnDaoMixin {
  final TxnDb db;

  // Called by the AppDatabase class
  TxnDao(this.db) : super(db);

  Future<List<Txn>> getAllTxn() => select(txn).get();
  Stream<List<Txn>> watchAllTxn() {
    // Wrap the whole select statement in parenthesis
    return (select(txn)
    // Statements like orderBy and where return void => the need to use a cascading ".." operator
      ..orderBy(
        ([
          // Primary sorting by timestamp
              (t) =>
              OrderingTerm(expression: t.timestamp, mode: OrderingMode.desc),
        ]),
      ))
    // watch the whole select statement
        .watch();
  }
  Stream<List<Txn>> watchMonthlyTxn() {
    // where returns void, need to use the cascading operator
    return (select(tasks)
      ..orderBy(
        ([
          // Primary sorting by due date
              (t) =>
              OrderingTerm(expression: t.dueDate, mode: OrderingMode.desc),
          // Secondary alphabetical sorting
              (t) => OrderingTerm(expression: t.name),
        ]),
      )
      ..where((t) => t.completed.equals(true)))
        .watch();
  }
  Stream<List<Txn>> watchYearlyTxn() {
    // where returns void, need to use the cascading operator
    return (select(tasks)
      ..orderBy(
        ([
          // Primary sorting by due date
              (t) =>
              OrderingTerm(expression: t.dueDate, mode: OrderingMode.desc),
          // Secondary alphabetical sorting
              (t) => OrderingTerm(expression: t.name),
        ]),
      )
      ..where((t) => t.completed.equals(true)))
        .watch();
  }
  Future insertTxn(Insertable<Txn> txn) => into(Txn).insert(txn);
  Future updateTxn(Insertable<Txn> txn) => update(Txn).replace(txn);
  Future deleteTxn(Insertable<Txn> txn) => delete(Txn).delete(txn);
}

// LazyDatabase _openConnection() {
//   // the LazyDatabase util lets us find the right location for the file async.
//   return LazyDatabase(() async {
//     // put the database file, called db.sqlite here, into the documents folder
//     // for your app.
//     final dbFolder = await getApplicationDocumentsDirectory();
//     final file = File(p.join(dbFolder.path, 'trans.db'));
//     return NativeDatabase(file);
//   });
// }
//
// Future<void> main() async {
//   final TransDatabase = TransDb();
//
//   // Simple insert:
//   await TransDatabase
//       .into(TransDatabase.name)
//       .insert(CategoriesCompanion.insert(description: 'my first category'));
//
//   // Simple select:
//   final allCategories = await TransDatabase.select(TransDatabase.categories).get();
//   print('Categories in TransDatabase: $allCategories');
// }

