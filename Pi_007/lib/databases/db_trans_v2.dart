import 'dart:io';

import 'package:drift/drift.dart';

// These imports are only needed to open the database
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
// Generated by drift_dev when running `build_runner build`
part 'db_trans_v2.g.dart';

//declaring a table called "dbTrans"
//rows of the table will be represented by a class called "dbTrans
@DataClassName('Txn')
class Txn extends Table {
  //a column that stores int values - id
  //autoincrement of id - primary key of this table
  IntColumn get id => integer().autoincrement()();

  BoolColumn get spending => boolean()();
  //must create a another category table for users to choose
  TextColumn get category => text()();
  //throw error if minLength is <1 or max is >50.
  TextColumn get name => text().withLength(min:1, max: 50)();

  RealColumn get amount => real()();

  TextColumn get note => text()();
  //how to set it as today's date as default
  DateTimeColumn get timestamp => dateTime().withDefault(currentDateAndTime)();
}

@DriftDatabase(tables : [Txn])
class TxnDb extends _$TransDb {
  //tell the database where to store the data with this constructor and logs it
  /*TransDb(): super(_openConnection());*/
  TransDb(): super(FlutterQueryExecutor.inDatabaseFolder(path: 'db.sqlite', logStatements: true));
  // you should bump this number whenever you change or add a table definition.
  // Migrations are covered later in the documentation.
  @override
  int get schemaVersion => 1;

  Future<List<Txn>> getAllTxn() => select(txn).get();
  Stream<List<Txn>> watchAllTxn() => select(txn).watch();
  Future insertTxn(Txn txn) => into(txn).insert(txn);
  Future updateTxn(Txn txn) => update(txn).replace(txn);
  Future deleteTcn(Txn txn) => delete(txn).delete(txn);


  // //loads all transaction entries
  // Future<List<DbTrans>> get allTransEntries => select(dbTrans).get();
  // // watches all dbTrans entries in a given category. The stream will automatically
  // // emit new items whenever the underlying data changes.
  // Stream<List<DbTrans>> watchEntriesInDbTrans(DbTrans c) {
  //   return (select(dbTrans)..where((t) => t.dbTrans.equals(c.id))).watch();
  // }
  // //The where method takes a function that should map the given table to an Expression of boolean.

}

// LazyDatabase _openConnection() {
//   // the LazyDatabase util lets us find the right location for the file async.
//   return LazyDatabase(() async {
//     // put the database file, called db.sqlite here, into the documents folder
//     // for your app.
//     final dbFolder = await getApplicationDocumentsDirectory();
//     final file = File(p.join(dbFolder.path, 'trans.db'));
//     return NativeDatabase(file);
//   });
// }
//
// Future<void> main() async {
//   final TransDatabase = TransDb();
//
//   // Simple insert:
//   await TransDatabase
//       .into(TransDatabase.name)
//       .insert(CategoriesCompanion.insert(description: 'my first category'));
//
//   // Simple select:
//   final allCategories = await TransDatabase.select(TransDatabase.categories).get();
//   print('Categories in TransDatabase: $allCategories');
// }
